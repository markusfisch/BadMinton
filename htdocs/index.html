<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
<meta name="theme-color" content="#111"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black"/>
<meta name="msapplication-navbutton-color" content="#111"/>
<title>Bad Minton</title>
<style>
html, body {
	margin: 0; padding: 0;
	background: #111;
	overflow: hidden;
	-webkit-tap-highlight-color: rgba(0,0,0,0);
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	-ms-touch-action: none;
	user-select: none;
}

canvas {
	position: fixed;
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<canvas id="Canvas">Sorry, this browser cannot render this content.</canvas>
<script id="VertexShader" type="x-shader/x-vertex">
attribute vec2 vertexPosition;
attribute vec2 texturePosition;

uniform mat3 perspective;
uniform mat3 transformation;

varying vec2 textureUV;

void main() {
	gl_Position = vec4(
		perspective *
		transformation *
		vec3(vertexPosition, 1.), 1.);

	textureUV = texturePosition;
}
</script>
<script id="FragmentShader" type="x-shader/x-fragment">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec2 textureUV;

uniform sampler2D texture;

void main() {
	vec4 color = texture2D(texture, textureUV.st);
	gl_FragColor = vec4(color.r, color.r, color.r, color.a);
}
</script>
<script>
'use strict'

var M = Math,
	D = document,
	W = window,
	FA = Float32Array,
	PLANET = 100,
	ASTRONAUT_IDLE0 = 200,
	ASTRONAUT_IDLE1 = 201,
	ASTRONAUT_MOVE0 = 202,
	ASTRONAUT_MOVE1 = 203,
	ASTRONAUT_MOVE2 = 204,
	ASTRONAUT_MOVE3 = 205,
	ASTRONAUT_CATCH0 = 206,
	ASTRONAUT_CATCH1 = 207,
	BALL = 208,
	STAR = 209,
	CARD_PLUS = 210,
	CARD_MINUS = 211,
	CARD_JIGGLE = 212,
	CARD_REVERSE = 213,
	atlas,
	sprites = [],
	gl,
	vertexPositionBuffer,
	vertexPositionLoc,
	texturePositionBuffer,
	texturePositionLoc,
	perspective,
	perspectiveLoc,
	transformation,
	transformationLoc,
	texture,
	textureLoc,
	program,
	halfWidth,
	halfHeight,
	yMax,
	scaleFactor,
	baseLine,
	horizon,
	planetBase,
	cardBase,
	cardX,
	letterSpacing,
	spaceWidth,
	playerRange,
	now,
	factor,
	last,
	pointersLength,
	pointersX = [],
	pointersY = [],
	keysDown = [],
	entitiesLength,
	entities,
	starsLength = 100,
	stars,
	starsVx,
	starsVy,
	cardFreq = 1000,
	cardsLength,
	cards,
	pone,
	ptwo,
	ball,
	started,
	ended,
	lost,
	computer

M.TAU = M.TAU || M.PI * 2
M.PI2 = M.PI2 || M.PI / 2

function drawSprite(sprite, x, y, wm, hm) {
	gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionBuffer)
	gl.vertexAttribPointer(texturePositionLoc, 2, gl.FLOAT, gl.FALSE, 0,
		sprite.index << 5)

	transformation[0] = sprite.w * (wm || 1)
	transformation[4] = sprite.h * (hm || 1)

	transformation[6] = x
	transformation[7] = y

	gl.uniformMatrix3fv(transformationLoc, gl.FALSE, transformation)
	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}

function measureText(text) {
	var width = 0
	for (var i = 0, len = text.length; i < len; ++i) {
		var c = text.charCodeAt(i)
		if (c == 32) {
			width += spaceWidth
		} else {
			width += sprites[c].ww + letterSpacing
		}
	}
	return width - (width > 0 ? letterSpacing : 0)
}

function drawText(text, x, y) {
	var width = measureText(text)
	x -= width / 2
	for (var i = 0, len = text.length; i < len; ++i) {
		var c = text.charCodeAt(i)
		if (c == 32) {
			x += spaceWidth
		} else {
			var sprite = sprites[c]
			drawSprite(sprite, x, y)
			x += sprite.ww + letterSpacing
		}
	}
}

function drawCard(player) {
	var since = now - player.playedCard,
		up = player.y > 0 ? -1 : 1,
		y = up > 0 ? cardBase : -cardBase
	if (since < cardFreq) {
		var drop = yMax - cardBase,
			dy = up > 0 ? -drop : drop
		y += dy * since / cardFreq
	} else if (player.playedCard > 0) {
		player.card = newCard()
		player.playedCard = 0
	}
	drawSprite(player.card.sprite, cardX, y, 1, up)
}

function drawAstronaut() {
	var sprite,
		freq,
		frames,
		e = this
	if (now - e.catched < 200) {
		frames = e.catchingLength
		sprite = e.catching[e.frame % frames]
		freq = e.catchingFreq
	} else {
		var dx = e.tx - e.x,
			dy = e.ty - e.y,
			adx = M.abs(dx),
			ady = M.abs(dy)
		if (adx < .001 && ady < .001) {
			frames = e.idleLength
			sprite = e.idle[e.frame % frames]
			freq = e.idleFreq
		} else {
			var speed = e.speed * factor
			if (adx > speed) {
				var d = dx > 0
				e.x += d ? speed : -speed
				e.direction = d ? 1 : -1
			} else {
				e.x = e.tx
			}
			if (ady > speed) {
				e.y += dy > 0 ? speed : -speed
			} else {
				e.y = e.ty
			}
			frames = e.moveLength
			sprite = e.move[e.frame % frames]
			freq = e.moveFreq
		}
	}
	if (frames > 1 && now - e.last > freq) {
		e.frame = (e.frame + 1) % frames
		e.last = now
	}
	drawCard(e)
	drawSprite(sprite, e.x, e.y - (e.height - sprite.h), e.direction, e.up)
}

function drawStars() {
	var sprite = sprites[STAR]
	for (var i = 0; i < starsLength; ++i) {
		var star = stars[i],
			x = star.x,
			y = star.y
		drawSprite(sprite, x, y)
		x += starsVx
		y += starsVy
		if (x > 1 || x < -1 || y > yMax || y < -yMax) {
			var p = 0,
				w = 2,
				h = yMax * 2,
				range = w + h

			p += range * M.random()

			if (p > w) {
				x = starsVx > 0 ? -1 : 1
				y = p - w - yMax
			} else {
				x = p - 1
				y = starsVy > 0 ? -yMax : yMax
			}
		}
		star.x = x
		star.y = y
	}
}

function initFrame() {
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
	gl.useProgram(program)

	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer)
	gl.vertexAttribPointer(vertexPositionLoc, 2, gl.FLOAT, gl.FALSE, 0, 0)
	gl.uniformMatrix3fv(perspectiveLoc, gl.FALSE, perspective)

	gl.activeTexture(gl.TEXTURE0)
	gl.bindTexture(gl.TEXTURE_2D, texture)
	gl.uniform1i(textureLoc, 0)
}

function moveTo(e, x) {
	var dx = x - e.tx,
		d = dx*dx
	if (d > e.speed / 2) {
		e.tx = M.min(horizon, M.max(-horizon, x))
	}
}

function newCard() {
	return cards[(M.random() * cardsLength) | 0]
}

function playCard(player) {
	if (now - player.playedCard < cardFreq) {
		return
	}
	player.card.play()
	player.playedCard = now
}

function contains(rc, x, y) {
	return x >= rc.l && x <= rc.r && y >= rc.t && y <= rc.b
}

function input() {
	if (lost) {
		if (pointersLength > 0 && now - ended > 1000) {
			resize()
		}
		return
	}
	if (!started) {
		if (M.abs(pone.x) < playerRange && pointersLength > 0) {
			computer = pointersY[0] < 0
			started = now
			pone.catched = now
			ball.x = pone.x
		}
		return
	}
	for (var i = 0; i < pointersLength; ++i) {
		var x = pointersX[i],
			y = pointersY[i]
		if (contains(pone.cardRect, x, y)) {
			playCard(pone)
			continue
		} else if (!computer && contains(ptwo.cardRect, x, y)) {
			playCard(ptwo)
			continue
		}
		if (y < 0) {
			moveTo(pone, x)
		} else if (!computer) {
			moveTo(ptwo, x)
		}
	}
	if (computer && ball.vy > 0) {
		var px = ptwo.x,
			bx = ball.x,
			by = ball.y,
			d = M.abs(baseLine) - by
		bx += ball.vx * d
		if (M.abs(ptwo.x - bx) > playerRange) {
			ptwo.tx = bx
		}
	}
}

function run() {
	requestAnimationFrame(run)

	now = Date.now()
	factor = (now - last) / 16
	last = now

	input()
	initFrame()

	drawStars()
	var planet = sprites[PLANET]
	drawSprite(planet, 0, planetBase)
	drawSprite(planet, 0, -planetBase, -1, -1)
	for (var i = 0; i < entitiesLength; ++i) {
		entities[i].draw()
	}

	if (!started) {
		var y = yMax * .2
		drawText('TAP HERE FOR 2 PLAYERS', 0, y)
		drawText('TAP HERE FOR 1 PLAYER', 0, -y)
	} else if (lost) {
		drawText('PLAYER ' + lost.name + ' LOST', 0, 0)
	}
}

function pageXToGl(x) {
	return (x - halfWidth) / halfWidth
}

function pageYToGl(y) {
	return (halfHeight - y) / (halfHeight / yMax)
}

function setPointer(event, down) {
	if (!down) {
		pointersLength = event.touches ? event.touches.length : 0
	} else if (event.touches) {
		var touches = event.touches
		pointersLength = touches.length
		for (var i = pointersLength; i--;) {
			var t = touches[i]
			pointersX[i] = pageXToGl(t.pageX)
			pointersY[i] = pageYToGl(t.pageY)
		}
	} else {
		pointersLength = 1
		pointersX[0] = pageXToGl(event.pageX)
		pointersY[0] = pageYToGl(event.pageY)
	}
	event.stopPropagation()
}

function pointerUp(event) {
	setPointer(event, false)
}

function pointerMove(event) {
	setPointer(event, pointersLength)
}

function pointerDown(event) {
	setPointer(event, true)
}

function setKey(event, down) {
	keysDown[event.keyCode] = down
	event.stopPropagation()
}

function keyUp(event) {
	setKey(event, false)
}

function keyDown(event) {
	setKey(event, true)
}

function getMaxHeight(sprites) {
	if (sprites == null) {
		return 0
	}
	var max = 0
	for (var i = sprites.length; i-- > 0;) {
		max = M.max(max, sprites[i].h)
	}
	return max
}

function getMaxHeightFromSets(sets) {
	var max = 0
	for (var i = sets.length; i-- > 0;) {
		max = M.max(max, getMaxHeight(sets[i]))
	}
	return max
}

function createStars() {
	stars = []
	for (var i = 0; i < starsLength; ++i) {
		stars.push({
			x: Math.random() * 2 - 1,
			y: Math.random() * yMax * 2 - yMax
		})
	}
	starsVx = .0001 + M.random() * .0005
	starsVy = .0001 + M.random() * .0005
}

function getCardRect(x, y) {
	var card = cards[0],
		w = card.sprite.w,
		h = card.sprite.h
	return {
		l: x - w,
		t: y - h,
		r: x + w,
		b: y + h
	}
}

function createEntities() {
	var astronautSpeed = scaleFactor * 6

	entities = []

	entities.push(pone = {
		name: 'ONE',
		idle: [
			sprites[ASTRONAUT_IDLE0],
			sprites[ASTRONAUT_IDLE1],
		],
		idleFreq: 2000,
		move: [
			sprites[ASTRONAUT_MOVE0],
			sprites[ASTRONAUT_MOVE1],
			sprites[ASTRONAUT_MOVE2],
			sprites[ASTRONAUT_MOVE3],
		],
		moveFreq: 100,
		catching: [
			sprites[ASTRONAUT_CATCH0],
			sprites[ASTRONAUT_CATCH1],
		],
		catchingFreq: 100,
		x: horizon,
		y: baseLine,
		direction: 1,
		up: 1,
		tx: 0,
		ty: baseLine,
		speed: astronautSpeed,
		draw: drawAstronaut,
		card: newCard(),
		cardRect: getCardRect(cardX, cardBase)
	})

	entities.push(ptwo = {
		name: 'TWO',
		idle: [
			sprites[ASTRONAUT_IDLE0],
			sprites[ASTRONAUT_IDLE1],
		],
		idleFreq: 2000,
		move: [
			sprites[ASTRONAUT_MOVE0],
			sprites[ASTRONAUT_MOVE1],
			sprites[ASTRONAUT_MOVE2],
			sprites[ASTRONAUT_MOVE3],
		],
		moveFreq: 100,
		catching: [
			sprites[ASTRONAUT_CATCH0],
			sprites[ASTRONAUT_CATCH1],
		],
		catchingFreq: 100,
		x: -horizon,
		y: -baseLine,
		direction: 1,
		up: -1,
		tx: 0,
		ty: -baseLine,
		speed: astronautSpeed,
		draw: drawAstronaut,
		card: newCard(),
		cardRect: getCardRect(cardX, -cardBase)
	})

	entities.push(ball = {
		sprite: sprites[BALL],
		x: 0,
		y: baseLine,
		vx: (scaleFactor + M.random() * scaleFactor * 2) *
			(M.random() > .5 ? 1 : -1),
		vy: scaleFactor * 5,
		draw: function() {
			if (!started) {
				return
			}
			var x = this.x,
				y = this.y
			x += this.vx * factor
			y += this.vy * factor
			if (!lost) {
				if (y < baseLine || y > -baseLine) {
					var player = y < baseLine ? pone : ptwo
					if (M.abs(player.x - x) < playerRange) {
						this.vy = -this.vy
						this.vy *= 1.05
						var d = player.tx - player.x
						if (M.abs(d) > .001) {
							this.vx += player.speed * (d > 0 ? -.2 : .2)
						}
						player.catched = now
					} else {
						lost = player
						ended = now
					}
				}
				if (x > horizon || x < -horizon) {
					this.vx = -this.vx
				}
			}
			this.x = x
			this.y = y
			drawSprite(this.sprite, x, y)
		}
	})

	entitiesLength = entities.length

	for (var i = 0; i < entitiesLength; ++i) {
		var e = entities[i]
		e.tx = typeof e.tx === 'undefined' ? e.x : e.tx
		e.ty = typeof e.ty === 'undefined' ? e.y : e.ty
		e.idleLength = e.idle ? e.idle.length : 0
		e.moveLength = e.move ? e.move.length : 0
		e.catchingLength = e.catching ? e.catching.length : 0
		e.height = getMaxHeightFromSets([e.idle, e.move, e.catching])
		e.frame = 0
		e.last = 0
		e.playedCard = 0
	}
}

function createCards() {
	cards = []
	cards.push({
		sprite: sprites[CARD_PLUS],
		play: function() {
			ball.vx *= 1.3
			ball.vy *= 1.3
		}
	})
	cards.push({
		sprite: sprites[CARD_MINUS],
		play: function() {
			if (M.abs(ball.vy) > scaleFactor) {
				ball.vx *= .5
				ball.vy *= .5
			}
		}
	})
	cards.push({
		sprite: sprites[CARD_JIGGLE],
		play: function() {
			ball.vx = -ball.vx
		}
	})
	cards.push({
		sprite: sprites[CARD_REVERSE],
		play: function() {
			ball.vy = -ball.vy
		}
	})
	cardsLength = cards.length
}

function scale(sprite) {
	var size = sprite.size * scaleFactor
	sprite.w = size
	sprite.ww = sprite.w * 2
	sprite.h = size * sprite.aspect
	sprite.hh = sprite.h * 2
}

function resize() {
	var width = gl.canvas.clientWidth,
		height = gl.canvas.clientHeight

	halfWidth = width >> 1
	halfHeight = height >> 1
	yMax = height / width

	gl.canvas.width = width
	gl.canvas.height = height
	gl.viewport(0, 0, width, height)

	var max = 500
	scaleFactor = yMax / max
	baseLine = scaleFactor * -(max - 100)
	planetBase = baseLine - scaleFactor * 72
	cardBase = baseLine + scaleFactor * 200

	perspective = new FA([
		1, 0, 0,
		0, width / height, 0,
		0, 0, 1])

	transformation = new FA([
		1, 0, 0,
		0, 1, 0,
		0, 0, 1])

	for (var id in sprites) {
		scale(sprites[id])
	}

	horizon = M.min(1, sprites[PLANET].w * .9)
	cardX = horizon - sprites[CARD_PLUS].w * 1.5
	spaceWidth = sprites[87].w
	letterSpacing = spaceWidth * -.05
	playerRange = sprites[ASTRONAUT_IDLE0].w * 1.5
	started = ended = lost = null

	createCards()
	createEntities()
	createStars()
}

function calculateSpriteRects() {
	var res = [
			PLANET, {/*planet*/x:1,y:1,w:650,h:78},
			ASTRONAUT_IDLE0, {/*astronaut_idle0*/x:761,y:1,w:48,h:75},
			ASTRONAUT_IDLE1, {/*astronaut_idle1*/x:177,y:81,w:51,h:71},
			ASTRONAUT_MOVE0, {/*astronaut_move0*/x:117,y:81,w:58,h:73},
			ASTRONAUT_MOVE1, {/*astronaut_move1*/x:60,y:81,w:55,h:78},
			ASTRONAUT_MOVE2, {/*astronaut_move2*/x:653,y:1,w:52,h:78},
			ASTRONAUT_MOVE3, {/*astronaut_move3*/x:707,y:1,w:52,h:77},
			ASTRONAUT_CATCH0, {/*astronaut_catch0*/x:1,y:81,w:57,h:87},
			ASTRONAUT_CATCH1, {/*astronaut_catch1*/x:230,y:81,w:47,h:70},
			BALL, {/*ball*/x:455,y:81,w:11,h:11},
			STAR, {/*star*/x:758,y:81,w:2,h:2},
			CARD_PLUS, {/*card_plus*/x:323,y:81,w:42,h:64},
			CARD_MINUS, {/*card_minus*/x:367,y:81,w:42,h:64},
			CARD_JIGGLE, {/*card_jiggle*/x:411,y:81,w:42,h:64},
			CARD_REVERSE, {/*card_reverse*/x:279,y:81,w:42,h:64},
			44, {/*ccomma*/x:748,y:81,w:3,h:4},
			46, {/*cpoint*/x:753,y:81,w:3,h:3},
			48, {/*c0*/x:719,y:81,w:5,h:7},
			49, {/*c1*/x:732,y:81,w:4,h:7},
			50, {/*c2*/x:712,y:81,w:5,h:7},
			51, {/*c3*/x:705,y:81,w:5,h:7},
			52, {/*c4*/x:698,y:81,w:5,h:7},
			53, {/*c5*/x:691,y:81,w:5,h:7},
			54, {/*c6*/x:684,y:81,w:5,h:7},
			55, {/*c7*/x:677,y:81,w:5,h:7},
			56, {/*c8*/x:670,y:81,w:5,h:7},
			57, {/*c9*/x:663,y:81,w:5,h:7},
			58, {/*ccolon*/x:743,y:81,w:3,h:5},
			33, {/*cexcl*/x:738,y:81,w:3,h:7},
			63, {/*cquest*/x:537,y:81,w:5,h:7},
			65, {/*cA*/x:656,y:81,w:5,h:7},
			66, {/*cB*/x:649,y:81,w:5,h:7},
			67, {/*cC*/x:642,y:81,w:5,h:7},
			68, {/*cD*/x:635,y:81,w:5,h:7},
			69, {/*cE*/x:628,y:81,w:5,h:7},
			70, {/*cF*/x:621,y:81,w:5,h:7},
			71, {/*cG*/x:614,y:81,w:5,h:7},
			72, {/*cH*/x:607,y:81,w:5,h:7},
			73, {/*cI*/x:600,y:81,w:5,h:7},
			74, {/*cJ*/x:726,y:81,w:4,h:7},
			75, {/*cK*/x:593,y:81,w:5,h:7},
			76, {/*cL*/x:586,y:81,w:5,h:7},
			77, {/*cM*/x:504,y:81,w:7,h:7},
			78, {/*cN*/x:529,y:81,w:6,h:7},
			79, {/*cO*/x:579,y:81,w:5,h:7},
			80, {/*cP*/x:572,y:81,w:5,h:7},
			81, {/*cQ*/x:521,y:81,w:6,h:7},
			82, {/*cR*/x:565,y:81,w:5,h:7},
			83, {/*cS*/x:558,y:81,w:5,h:7},
			84, {/*cT*/x:551,y:81,w:5,h:7},
			85, {/*cU*/x:544,y:81,w:5,h:7},
			86, {/*cV*/x:495,y:81,w:7,h:7},
			87, {/*cW*/x:486,y:81,w:7,h:7},
			88, {/*cX*/x:477,y:81,w:7,h:7},
			89, {/*cY*/x:468,y:81,w:7,h:7},
			90, {/*cZ*/x:513,y:81,w:6,h:7},
		],
		positions = [],
		xf = 1 / atlas.width,
		yf = 1 / atlas.height,
		index = 0

	for (var i = res.length; i > 0;) {
		var rc = res[--i],
			id = res[--i],
			x = rc.x,
			y = rc.y,
			w = rc.w,
			h = rc.h,
			l = xf * x,
			t = yf * y,
			r = xf * (x + w),
			b = yf * (y + h)

		sprites[id] = {
			index: index++,
			aspect: h / w,
			size: id < 100 ? w * 2 : w
		}

		/* TRIANGLE_STRIP order:
		 *   A--C   A: x, y
		 *   | /|   B: x, y
		 *   |/ |   C: x, y
		 *   B--D   D: x, y */
		positions.push(
			l, t,
			l, b,
			r, t,
			r, b)
	}

	return positions
}

function getEnabledAttribLocation(program, name) {
	var loc = gl.getAttribLocation(program, name)
	gl.enableVertexAttribArray(loc)
	return loc
}

function initBuffers(program) {
	vertexPositionBuffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer)
	gl.bufferData(gl.ARRAY_BUFFER,
		new FA([
			-1, 1,
			-1, -1,
			1, 1,
			1, -1]),
		gl.STATIC_DRAW)

	texturePositionBuffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionBuffer)
	gl.bufferData(gl.ARRAY_BUFFER, new FA(calculateSpriteRects()),
		gl.STATIC_DRAW)

	vertexPositionLoc = getEnabledAttribLocation(program, 'vertexPosition')
	texturePositionLoc = getEnabledAttribLocation(program, 'texturePosition')
	perspectiveLoc = gl.getUniformLocation(program, 'perspective')
	transformationLoc = gl.getUniformLocation(program, 'transformation')
	textureLoc = gl.getUniformLocation(program, 'texture')
}

function createTextureFrom(image) {
	var id = gl.createTexture()
	if (id < 1) {
		return
	}

	gl.bindTexture(gl.TEXTURE_2D, id)
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
		image)

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

	gl.generateMipmap(gl.TEXTURE_2D)
	gl.bindTexture(gl.TEXTURE_2D, null)

	return id
}

function start() {
	if (!(texture = createTextureFrom(atlas))) {
		alert('Cannot initialize atlas texture')
		return
	}

	gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	gl.clearColor(.06, .06, .06, 1)

	initBuffers(program)

	W.onresize = resize
	resize()

	D.onkeydown = keyDown
	D.onkeyup = keyUp

	D.onmousedown = pointerDown
	D.onmousemove = pointerMove
	D.onmouseup = pointerUp
	D.onmouseout = pointerUp

	if ('ontouchstart' in D) {
		D.ontouchstart = pointerDown
		D.ontouchmove = pointerMove
		D.ontouchend = pointerUp
		D.ontouchleave = pointerUp
		D.ontouchcancel = pointerUp
	}

	last = Date.now() - 16
	run()
}

function compileShader(src, type) {
	var shader = gl.createShader(type)
	gl.shaderSource(shader, src)
	gl.compileShader(shader)
	return gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : null
}

function linkProgram(vs, fs) {
	var p
	if ((p = gl.createProgram())) {
		gl.attachShader(p, vs)
		gl.attachShader(p, fs)
		gl.linkProgram(p)
		if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
			gl.deleteProgram(p)
			p = null
		}
	}
	return p
}

function buildProgram(vertexSource, fragmentSource) {
	var p, vs, fs
	if ((vs = compileShader(vertexSource, gl.VERTEX_SHADER))) {
		if ((fs = compileShader(fragmentSource, gl.FRAGMENT_SHADER))) {
			p = linkProgram(vs, fs)
			gl.deleteShader(fs)
		}
		gl.deleteShader(vs)
	}
	return p
}

function getContext() {
	var canvas = D.getElementById('Canvas')
	for (var ctx,
			types = ['webgl', 'experimental-webgl'],
			l = types.length,
			i = 0; i < l; ++i) {
		if ((ctx = canvas.getContext(types[i], {alpha: false}))) {
			return ctx
		}
	}
}

function load() {
	if (!(gl = getContext()) || !(program = buildProgram(
			D.getElementById('VertexShader').textContent,
			D.getElementById('FragmentShader').textContent))) {
		alert('WebGL not available')
		return
	}

	atlas = new Image()
	atlas.src = 'atlas.png'
	atlas.onload = start
}

W.onload = load
</script>
</body>
</html>
