<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
<meta name="theme-color" content="#111"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black"/>
<meta name="msapplication-navbutton-color" content="#111"/>
<title>ld41</title>
<style>
html, body {
	margin: 0; padding: 0;
	background: #111;
	overflow: hidden;
	-webkit-tap-highlight-color: rgba(0,0,0,0);
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	-ms-touch-action: none;
	user-select: none;
}

canvas {
	position: fixed;
	width: 100%;
	height: 100%;
}
</style>
</head>
<body>
<canvas id="Canvas">Sorry, this browser cannot render this content.</canvas>
<script id="VertexShader" type="x-shader/x-vertex">
attribute vec2 vertexPosition;
attribute vec2 texturePosition;

uniform mat3 perspective;
uniform mat3 transformation;

varying vec2 textureUV;

void main() {
	gl_Position = vec4(
		perspective *
		transformation *
		vec3(vertexPosition, 1.), 1.);

	textureUV = texturePosition;
}
</script>
<script id="FragmentShader" type="x-shader/x-fragment">
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec2 textureUV;

uniform sampler2D texture;

void main() {
	vec4 color = texture2D(texture, textureUV.st);
	gl_FragColor = vec4(color.r, color.r, color.r, color.a);
}
</script>
<script>
'use strict'

var M = Math,
	D = document,
	W = window,
	FA = Float32Array,
	PLANET = 100,
	ASTRONAUT_IDLE0 = 200,
	ASTRONAUT_IDLE1 = 201,
	ASTRONAUT_MOVE0 = 202,
	ASTRONAUT_MOVE1 = 203,
	ASTRONAUT_MOVE2 = 204,
	ASTRONAUT_MOVE3 = 205,
	atlas,
	sprites = [],
	gl,
	vertexPositionBuffer,
	vertexPositionLoc,
	texturePositionBuffer,
	texturePositionLoc,
	perspective,
	perspectiveLoc,
	transformation,
	transformationLoc,
	texture,
	textureLoc,
	program,
	halfWidth,
	halfHeight,
	yMax,
	scaleFactor,
	letterSpacing,
	spaceWidth,
	now,
	factor,
	last,
	pointersLength,
	pointersX = [],
	pointersY = [],
	keysDown = [],
	entitiesLength,
	entities,
	player

M.TAU = M.TAU || M.PI * 2
M.PI2 = M.PI2 || M.PI / 2

function drawSprite(sprite, x, y, wm, hm) {
	gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionBuffer)
	gl.vertexAttribPointer(texturePositionLoc, 2, gl.FLOAT, gl.FALSE, 0,
		sprite.index << 5)

	transformation[0] = sprite.w * (wm || 1)
	transformation[4] = sprite.h * (hm || 1)

	transformation[6] = x
	transformation[7] = y

	gl.uniformMatrix3fv(transformationLoc, gl.FALSE, transformation)
	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}

function measureText(text) {
	var width = 0
	for (var i = 0, len = text.length; i < len; ++i) {
		var c = text.charCodeAt(i)
		if (c == 32) {
			width += spaceWidth
		} else {
			var sprite = sprites[c]
			width += sprite.w + letterSpacing
		}
	}
	return width - (width > 0 ? letterSpacing : 0)
}

function drawText(text, x, y) {
	var width = measureText(text)
	x -= width / 2
	for (var i = 0, len = text.length; i < len; ++i) {
		var c = text.charCodeAt(i)
		if (c == 32) {
			x += spaceWidth
		} else {
			var sprite = sprites[c]
			drawSprite(sprite, x, y)
			x += sprite.w + letterSpacing
		}
	}
}

function drawEntity(e, wx, wy) {
	var sprite,
		freq,
		frames,
		dx = e.tx - e.x,
		dy = e.ty - e.y,
		adx = M.abs(dx),
		ady = M.abs(dy)
	if (adx < .001 && ady < .001) {
		frames = e.idleLength
		sprite = e.idle[e.frame % frames]
		freq = e.idleFreq
		if (e.finished) {
			e.finished()
		}
	} else {
		var speed = e.speed * factor
		if (adx > speed) {
			var d = dx > 0
			e.x += d ? speed : -speed
			e.direction = d ? 1 : -1
		} else {
			e.x = e.tx
		}
		if (ady > speed) {
			e.y += dy > 0 ? speed : -speed
		} else {
			e.y = e.ty
		}
		frames = e.moveLength
		sprite = e.move[e.frame % frames]
		freq = e.moveFreq
		if (e.moved) {
			e.moved()
		}
	}
	if (frames > 0 && now - e.last > freq) {
		++e.frame
		e.last = now
	}
	drawSprite(sprite, e.x - wx, e.y - (e.height - sprite.h) - wy,
		e.direction)
}

function initFrame() {
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
	gl.useProgram(program)

	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer)
	gl.vertexAttribPointer(vertexPositionLoc, 2, gl.FLOAT, gl.FALSE, 0, 0)
	gl.uniformMatrix3fv(perspectiveLoc, gl.FALSE, perspective)

	gl.activeTexture(gl.TEXTURE0)
	gl.bindTexture(gl.TEXTURE_2D, texture)
	gl.uniform1i(textureLoc, 0)
}

function setTarget(e, x) {
	var dx = x - e.tx,
		d = dx*dx
	if (d > e.speed) {
		var max = sprites[PLANET].w * .93
		e.tx = M.min(max, M.max(-max, x))
	}
}

function input() {
	if (pointersLength > 0) {
		setTarget(player, player.x + pointersX[0])
	}
}

function run() {
	requestAnimationFrame(run)

	now = Date.now()
	factor = (now - last) / 16
	last = now

	input()
	initFrame()

	var wx = player.x,
		wy = player.y
	drawSprite(sprites[PLANET], -wx, wy + scaleFactor * 120)
	for (var i = 0; i < entitiesLength; ++i) {
		drawEntity(entities[i], wx, wy)
	}
	drawText("WHERE IS IT?", 0, scaleFactor * 120)
}

function pageXToGl(x) {
	return (x - halfWidth) / halfWidth
}

function pageYToGl(y) {
	return (halfHeight - y) / (halfHeight / yMax)
}

function setPointer(event, down) {
	if (!down) {
		pointersLength = event.touches ? event.touches.length : 0
	} else if (event.touches) {
		var touches = event.touches
		pointersLength = touches.length
		for (var i = pointersLength; i--;) {
			var t = touches[i]
			pointersX[i] = pageXToGl(t.pageX)
			pointersY[i] = pageYToGl(t.pageY)
		}
	} else {
		pointersLength = 1
		pointersX[0] = pageXToGl(event.pageX)
		pointersY[0] = pageYToGl(event.pageY)
	}
	event.stopPropagation()
}

function pointerUp(event) {
	setPointer(event, false)
}

function pointerMove(event) {
	setPointer(event, pointersLength)
}

function pointerDown(event) {
	setPointer(event, true)
}

function setKey(event, down) {
	keysDown[event.keyCode] = down
	event.stopPropagation()
}

function keyUp(event) {
	setKey(event, false)
}

function keyDown(event) {
	setKey(event, true)
}

function getMaxHeight(sprites) {
	if (sprites == null) {
		return 0
	}
	var max = 0
	for (var i = sprites.length; i-- > 0;) {
		max = M.max(max, sprites[i].h)
	}
	return max
}

function createEntities() {
	entities = []

	entities.push(player = {
		idle: [
			sprites[ASTRONAUT_IDLE0],
			sprites[ASTRONAUT_IDLE1],
		],
		idleFreq: 2000,
		move: [
			sprites[ASTRONAUT_MOVE0],
			sprites[ASTRONAUT_MOVE1],
			sprites[ASTRONAUT_MOVE2],
			sprites[ASTRONAUT_MOVE3],
		],
		moveFreq: 100,
		x: 0,
		y: -yMax,
		direction: 1,
		tx: 0,
		ty: 0,
		speed: scaleFactor * 5,
	})

	entitiesLength = entities.length

	for (var i = 0; i < entitiesLength; ++i) {
		var e = entities[i]
		e.tx = typeof e.tx === 'undefined' ? e.x : e.tx
		e.ty = typeof e.ty === 'undefined' ? e.y : e.ty
		e.idleLength = e.idle ? e.idle.length : 0
		e.moveLength = e.move ? e.move.length : 0
		e.height = M.max(getMaxHeight(e.idle), getMaxHeight(e.move))
		e.frame = 0
		e.last = 0
	}
}

function scale(sprite) {
	var size = sprite.size * scaleFactor
	sprite.w = size
	sprite.h = size * sprite.aspect
}

function resize() {
	var width = gl.canvas.clientWidth,
		height = gl.canvas.clientHeight

	halfWidth = width >> 1
	halfHeight = height >> 1
	yMax = height / width

	gl.canvas.width = width
	gl.canvas.height = height
	gl.viewport(0, 0, width, height)

	var ref = sprites[ASTRONAUT_IDLE0].size * 5
	scaleFactor = .45 / halfWidth * M.min(width / ref, height / ref)
	letterSpacing = scaleFactor * 5
	spaceWidth = scaleFactor * 10

	perspective = new FA([
		1, 0, 0,
		0, width / height, 0,
		0, 0, 1])

	transformation = new FA([
		1, 0, 0,
		0, 1, 0,
		0, 0, 1])

	for (var id in sprites) {
		scale(sprites[id])
	}

	createEntities()
}

function calculateSpriteRects() {
	var res = [
			PLANET, {/*planet*/x:1,y:1,w:1715,h:291},
			ASTRONAUT_IDLE0, {/*astronaut_idle0*/x:1770,y:76,w:35,h:68},
			ASTRONAUT_IDLE1, {/*astronaut_idle1*/x:1770,y:146,w:33,h:69},
			ASTRONAUT_MOVE0, {/*astronaut_move0*/x:1718,y:1,w:50,h:69},
			ASTRONAUT_MOVE1, {/*astronaut_move1*/x:1770,y:1,w:42,h:73},
			ASTRONAUT_MOVE2, {/*astronaut_move2*/x:1718,y:144,w:42,h:75},
			ASTRONAUT_MOVE3, {/*astronaut_move3*/x:1718,y:72,w:47,h:70},
			44, {/*ccomma*/x:1805,y:209,w:3,h:4},
			46, {/*cpoint*/x:1808,y:244,w:3,h:3},
			48, {/*c0*/x:1784,y:244,w:5,h:7},
			49, {/*c1*/x:1797,y:244,w:4,h:7},
			50, {/*c2*/x:1777,y:244,w:5,h:7},
			51, {/*c3*/x:1770,y:244,w:5,h:7},
			52, {/*c4*/x:1805,y:235,w:5,h:7},
			53, {/*c5*/x:1798,y:235,w:5,h:7},
			54, {/*c6*/x:1791,y:235,w:5,h:7},
			55, {/*c7*/x:1784,y:235,w:5,h:7},
			56, {/*c8*/x:1777,y:235,w:5,h:7},
			57, {/*c9*/x:1770,y:235,w:5,h:7},
			58, {/*ccolon*/x:1807,y:139,w:3,h:5},
			33, {/*cexcl*/x:1803,y:244,w:3,h:7},
			63, {/*cquest*/x:1807,y:76,w:5,h:7},
			65, {/*cA*/x:1805,y:226,w:5,h:7},
			66, {/*cB*/x:1798,y:226,w:5,h:7},
			67, {/*cC*/x:1791,y:226,w:5,h:7},
			68, {/*cD*/x:1784,y:226,w:5,h:7},
			69, {/*cE*/x:1777,y:226,w:5,h:7},
			70, {/*cF*/x:1770,y:226,w:5,h:7},
			71, {/*cG*/x:1806,y:217,w:5,h:7},
			72, {/*cH*/x:1799,y:217,w:5,h:7},
			73, {/*cI*/x:1792,y:217,w:5,h:7},
			74, {/*cJ*/x:1791,y:244,w:4,h:7},
			75, {/*cK*/x:1785,y:217,w:5,h:7},
			76, {/*cL*/x:1778,y:217,w:5,h:7},
			77, {/*cM*/x:1805,y:182,w:7,h:7},
			78, {/*cN*/x:1770,y:217,w:6,h:7},
			79, {/*cO*/x:1807,y:130,w:5,h:7},
			80, {/*cP*/x:1807,y:121,w:5,h:7},
			81, {/*cQ*/x:1805,y:200,w:6,h:7},
			82, {/*cR*/x:1807,y:112,w:5,h:7},
			83, {/*cS*/x:1807,y:103,w:5,h:7},
			84, {/*cT*/x:1807,y:94,w:5,h:7},
			85, {/*cU*/x:1807,y:85,w:5,h:7},
			86, {/*cV*/x:1805,y:173,w:7,h:7},
			87, {/*cW*/x:1805,y:164,w:7,h:7},
			88, {/*cX*/x:1805,y:155,w:7,h:7},
			89, {/*cY*/x:1805,y:146,w:7,h:7},
			90, {/*cZ*/x:1805,y:191,w:6,h:7},
		],
		positions = [],
		xf = 1 / atlas.width,
		yf = 1 / atlas.height,
		index = 0

	for (var i = res.length; i > 0;) {
		var rc = res[--i],
			id = res[--i],
			x = rc.x,
			y = rc.y,
			w = rc.w,
			h = rc.h,
			l = xf * x,
			t = yf * y,
			r = xf * (x + w),
			b = yf * (y + h)

		sprites[id] = {
			index: index++,
			aspect: h / w,
			size: w
		}

		/* TRIANGLE_STRIP order:
		 *   A--C   A: x, y
		 *   | /|   B: x, y
		 *   |/ |   C: x, y
		 *   B--D   D: x, y */
		positions.push(
			l, t,
			l, b,
			r, t,
			r, b)
	}

	return positions
}

function getEnabledAttribLocation(program, name) {
	var loc = gl.getAttribLocation(program, name)
	gl.enableVertexAttribArray(loc)
	return loc
}

function initBuffers(program) {
	vertexPositionBuffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer)
	gl.bufferData(gl.ARRAY_BUFFER,
		new FA([
			-1, 1,
			-1, -1,
			1, 1,
			1, -1]),
		gl.STATIC_DRAW)

	texturePositionBuffer = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionBuffer)
	gl.bufferData(gl.ARRAY_BUFFER, new FA(calculateSpriteRects()),
		gl.STATIC_DRAW)

	vertexPositionLoc = getEnabledAttribLocation(program, 'vertexPosition')
	texturePositionLoc = getEnabledAttribLocation(program, 'texturePosition')
	perspectiveLoc = gl.getUniformLocation(program, 'perspective')
	transformationLoc = gl.getUniformLocation(program, 'transformation')
	textureLoc = gl.getUniformLocation(program, 'texture')
}

function createTextureFrom(image) {
	var id = gl.createTexture()
	if (id < 1) {
		return
	}

	gl.bindTexture(gl.TEXTURE_2D, id)
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
		image)

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

	gl.generateMipmap(gl.TEXTURE_2D)
	gl.bindTexture(gl.TEXTURE_2D, null)

	return id
}

function start() {
	if (!(texture = createTextureFrom(atlas))) {
		alert('Cannot initialize atlas texture')
		return
	}

	gl.enable(gl.BLEND)
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
	gl.clearColor(.06, .06, .06, 1)

	initBuffers(program)

	W.onresize = resize
	resize()

	D.onkeydown = keyDown
	D.onkeyup = keyUp

	D.onmousedown = pointerDown
	D.onmousemove = pointerMove
	D.onmouseup = pointerUp
	D.onmouseout = pointerUp

	if ('ontouchstart' in D) {
		D.ontouchstart = pointerDown
		D.ontouchmove = pointerMove
		D.ontouchend = pointerUp
		D.ontouchleave = pointerUp
		D.ontouchcancel = pointerUp
	}

	last = Date.now() - 16
	run()
}

function compileShader(src, type) {
	var shader = gl.createShader(type)
	gl.shaderSource(shader, src)
	gl.compileShader(shader)
	return gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : null
}

function linkProgram(vs, fs) {
	var p
	if ((p = gl.createProgram())) {
		gl.attachShader(p, vs)
		gl.attachShader(p, fs)
		gl.linkProgram(p)
		if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
			gl.deleteProgram(p)
			p = null
		}
	}
	return p
}

function buildProgram(vertexSource, fragmentSource) {
	var p, vs, fs
	if ((vs = compileShader(vertexSource, gl.VERTEX_SHADER))) {
		if ((fs = compileShader(fragmentSource, gl.FRAGMENT_SHADER))) {
			p = linkProgram(vs, fs)
			gl.deleteShader(fs)
		}
		gl.deleteShader(vs)
	}
	return p
}

function getContext() {
	var canvas = D.getElementById('Canvas')
	for (var ctx,
			types = ['webgl', 'experimental-webgl'],
			l = types.length,
			i = 0; i < l; ++i) {
		if ((ctx = canvas.getContext(types[i], {alpha: false}))) {
			return ctx
		}
	}
}

function load() {
	if (!(gl = getContext()) || !(program = buildProgram(
			D.getElementById('VertexShader').textContent,
			D.getElementById('FragmentShader').textContent))) {
		alert('WebGL not available')
		return
	}

	atlas = new Image()
	atlas.src = 'atlas.png'
	atlas.onload = start
}

W.onload = load
</script>
</body>
</html>
